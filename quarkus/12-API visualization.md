# 12 - API Visualization

Code: https://github.com/apedano/kubernetes-native-microservices-sources/tree/ch-12 (the code is based on the `account-service` of chapter 2)

In 2016, the *Swagger specification* was rebranded as the *OpenAPI specification* under a new OpenAPI initiative sponsored by the Linux Foundation. 
Other benefits to an OpenAPI specification of a service follow: 
* Creating interactive documentation of a service
* Automation of test cases based on a specification
* Generating clients or services aligned with a specification

The OpenAPI specification (**OAS**) is designed for such purposes. The version of the specification is currently **v3**.

## Viewing OpenAPI documents with Swagger UI

* Providing an OpenAPI specification file
* Visualizing it with Swagger UI

Without the former, the latter has nothing to show.

## Enabling OpenAPI

```xml
<dependency>
 <groupId>io.quarkus</groupId>
 <artifactId>quarkus-smallrye-openapi</artifactId>
</dependency>
```

With this, the Account service will have an *OpenAPI* document produced from the code by running:

`mvn quarkus:dev` at `http://localhost:8080/q/openapi` (`http://localhost:8080/q/openapi?format=json`). The produced file is a descriptor of the application resources like:

```yaml
---
openapi: 3.0.3
info:
  title: account-service API
  version: 1.0.0-SNAPSHOT
paths:
  /accounts:
    get:
      tags:
      - Account Resource
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                uniqueItems: true
                type: array
                items:
                  $ref: '#/components/schemas/Account'
...
components:
  schemas:
    Account:
      type: object
      properties:
        accountNumber:
          format: int64
          type: integer
        customerNumber:
          format: int64
          type: integer
        customerName:
          type: string
        balance:
          type: number
        accountStatus:
          $ref: '#/components/schemas/AccountStatus'
```

## Swagger UI

With Quarkus, *Swagger UI* is packaged as part of the OpenAPI extension on


`http://localhost:8080/q/swagger-ui/`

The Swagger UI **is present, by default, only during live coding and testing**, not as part of a final, packaged build. For production, it is recommended to use a separate Swagger UI instance that can be properly secured using the OpenAPI document produced from a service. **The default behavior can be overridden** by adding `quarkus.swagger-ui.always-include=true` to application.properties. However, the configuration is for build time only, which means the configuration value can not
be altered once a service is built. Setting this property for production use **is not recommended**.


## Design first development
*Design-first* development (aka *contract-first development*) is when an **OpenAPI
document is created by describing the service being developed before writing any
code**. Once validated, an OpenAPI generator can then be used to generate the service based on the OpenAPI document as a starting point for implementing
a service. This process is **one-way**: once the implementing code is developed it is not possible to maintain it automatically, through the generator if the contract changes. This must be done manually: the implementation should start only once the contract has been stabilized.

### API GUI generation tools
Design tools from an OpenAPI document to generate and API GUI (like Swagger UI):

* [Swagger Editor](https://swagger.io/tools/swagger-editor/) from the
creators of the OpenAPI Specification
* [Apicurio Studio](https://www.apicur.io/studio/)

### API code generation tools

[OpenAPI Generator](https://openapi-generator.tech/)

### Swagger UI generation with Quarkus

### Fully OpenAPI document based

We can add the OpenAPI document generated by Quarkus to `META-INF/openapi.yaml` and add the following property:

```properties
#will ensure the #static OpenAPI document in the project will be served “as is.”
# Without this setting, Quarkus will generate an OpenAPI document combining
# the static document with the model generated from the application code.
mp.openapi.scan.disable=true
```
To generate a Swagger UI page fully based on the provided document.

### Merge document and code

We have to disable the previous property and add some annotations to one method of the `AccountResource`

```java
@Tag(name = "get-by-accountnumber", description = "Separate grouping because we can")
@APIResponse(responseCode = "200", description = "Successfully retrieved an account.",
        content = @Content(
                schema = @Schema(implementation = Account.class))
)
@APIResponse(responseCode = "400", description = "Account with id of {accountNumber} does not exist.",
        content = @Content(
                schema = @Schema(
                        implementation = ResourceErrorMapper.ErrorResponse.class,
                        example = "{\n" +
                                "\"exceptionType\": \"javax.ws.rs.WebApplicationException\",\n" +
                                "\"code\": 400,\n" +
                                "\"error\": \"Account with id of 12345678 does not exist.\"\n" +
                        "}\n")
        )
)
@GET
@Path("/{accountNumber}")
@Produces(MediaType.APPLICATION_JSON)
public Account getAccount(
        @Parameter(name = "accountNumber", description = "Number of the Account instance to be retrieved.",
                required = true, in = ParameterIn.PATH, example = "123456789")
        @PathParam("accountNumber") Long accountNumber) {
    Optional<Account> response = accounts.stream()
            .filter(acct -> acct.getAccountNumber().equals(accountNumber))
            .findFirst();
    return response.orElseThrow(()
            -> new WebApplicationException("Account with id of " + accountNumber + " does not exist.", 404));
}
```

The generated Swagger UI will be the result of the scan of the document with the additions resulting from the scan of the implementing code (annotations).





